module srl_nokia-te-policies {
  yang-version 1.1;

  // namespace

  namespace "urn:srl_nokia/te-policies";
  prefix srl_nokia-te-policies;

  import srl_nokia-common {
    prefix srl_nokia-comm;
  }
  import srl_nokia-network-instance {
    prefix srl_nokia-netinst;
  }
  import srl_nokia-system {
    prefix srl_nokia-system;
  }
  import srl_nokia-mpls-label-management {
    prefix srl_nokia-mplslbl;
  }
  import srl_nokia-features {
    prefix srl_nokia-feat;
  }
  import srl_nokia-maintenance-policies {
    prefix srl_nokia-maint-pol;
  }
  import srl_nokia-traffic-engineering {
    prefix srl_nokia-te;
  }
  import srl_nokia-routing-policy {
    prefix srl_nokia-routing-pol;
  }

  organization
    "Nokia";
  contact
    "Nokia SR Linux Support
     Web: <http://www.nokia.com>";

  description
    "Configuration and state for traffic engineering policies.";

  revision 2023-07-31 {
    description
      "SRLinux 23.7.1";
  }
  revision 2023-03-31 {
    description
      "SRLinux 23.3.1";
  }

  identity policy-invalid-reason {
    description
      "Base identity for reasons that describe why a candidate path is invalid";
  }

  identity admin-disabled {
    base policy-invalid-reason;
    description
      "The candidate path is administratively disabled";
  }

  identity no-valid-segment-list {
    base policy-invalid-reason;
    description
      "The candidate path has no valid segment lists";
  }

  identity no-binding-sid-label {
    base policy-invalid-reason;
    description
      "No free labels in the label-range";
  }

  typedef policy-invalid-reason-type {
    type identityref {
      base policy-invalid-reason;
    }
  }

  identity te-policy-oper-down-reason {
    description
      "Base identity for reasons that describe why a TE policy is operationally down";
  }

  identity te-policy-admin-disabled {
    base te-policy-oper-down-reason;
    description
      "The TE policy is administratively disabled";
  }

  identity te-policy-no-valid-segment-list {
    base te-policy-oper-down-reason;
    description
      "The TE policy has no valid segment lists";
  }

  typedef te-policy-oper-down-reason-type {
    type identityref {
      base te-policy-oper-down-reason;
    }
  }

  typedef te-policy-type {
    type enumeration {
      enum sr-mpls-colored;
      enum sr-mpls-uncolored;
    }
  }

  typedef dynamic-segment-path-computation-type {
    type enumeration {
      enum local-cspf;
      enum pce;
    }
  }

  typedef protocol-origin-type {
    type enumeration {
      enum pcep {
        value 10;
        description
          "PCEP used as signalling mechanism for the candidate path";
      }
      enum bgp {
        value 20;
        description
          "BGP used as signalling mechanism for the candidate path";
      }
      enum local {
        value 30;
        description
          "Management interface used for candidate path instantiation";
      }
    }
    description
      "Originating protocol type";
  }

  typedef candidate-path-type {
    type enumeration {
      enum best {
        description
          "The candidate path is the best valid path but it does not have a protection policy with SBFD enabled";
      }
      enum primary {
        description
          "The candidate path is the best valid path and it has a protection policy with SBFD enabled.";
      }
      enum secondary {
        description
          "The candidate path is the second best valid path and it has a protection policy with SBFD enabled.";
      }
      enum tertiary {
        description
          "The candidate path is the third best valid path and it has a protection policy with SBFD enabled.";
      }
      enum other {
        description
          "The candidate path is invalid or else it is valid but without special designation as best, primary, secondary or tertiary.";
      }
    }
  }

  typedef te-policy-oper-state {
    type enumeration {
      enum up {
        description
          "The te-policy is operationally up.";
      }
      enum down {
        description
          "The te-policy is administratively down or no valid segment-list or due to other reasons.";
      }
    }
  }

  typedef segment-list-oper-state {
    type enumeration {
      enum up {
        description
          "The segment-list is valid and belongs to a candidate path that is best, primary, secondary or tertiary and if SBFD is enabled, the SBFD session state is up.";
        value 1;
      }
      enum sbfd-down {
        description
          "The segment-list is valid and belongs to a candidate path that is primary, secondary or tertiary but the SBFD session state is down (or in hold-down).";
        value 2;
      }
      enum valid {
        description
          "The segment-list is valid but does not belong to a candidate path that is best, primary, secondary or tertiary";
        value 3;
      }
      enum invalid {
        description
          "The segment-list is invalid and the reason will be provided";
        value 4;
      }
      enum down {
        description
          "The parent te-policy/candidate path is administratively disabled, or this segment list has been administratively disabled";
        value 5;
      }
    }
  }

  identity segment-list-invalid-reason {
    description
      "Base identity for reasons that describe why a segment list is invalid.";
  }

  identity unresolved-first-segment {
    base segment-list-invalid-reason;
    description
      "The system is unable to resolve the first SID (MPLS label value) into one or more outgoing interface(s) and next-hop(s)";
  }

  identity unresolved-named-path {
    base segment-list-invalid-reason;
    description
      "The most recent query to TEDB about the named path (triggered by periodic re-optimization or initially) indicated that the named path is not viable.";
  }

  identity maximum-label-stack-depth-exceeded {
    base segment-list-invalid-reason;
    description
      "The resolution of the named path requires more labels than supported by the hardware datapath.";
  }

  typedef segment-list-invalid-reason-type {
    type identityref {
      base segment-list-invalid-reason;
    }
  }

  grouping te-policies-top {
    container traffic-engineering-policies {
      if-feature "srl_nokia-feat:te-policies";
      presence "Configure traffic engineering policies";
      description
        "Container with traffic engineering policies";
      uses binding-sid-label-blocks;
      uses named-paths;
      //uses srl_nokia-maint-pol:maintenance-policies;
      uses te-policies;
      uses policy-database;
    }
  }

  grouping binding-sid-label-blocks {
    container binding-sid {
      if-feature "srl_nokia-feat:label-management";
      description
        "Configuration and state related to the label block(s) used for the binding SIDs associated with TE policies";
      leaf static-label-block {
        type leafref {
          path "/srl_nokia-system:system/srl_nokia-mplslbl:mpls/srl_nokia-mplslbl:label-ranges/srl_nokia-mplslbl:static/srl_nokia-mplslbl:name";
        }
        must 'not(/srl_nokia-system:system/srl_nokia-mplslbl:mpls/srl_nokia-mplslbl:label-ranges/srl_nokia-mplslbl:static[srl_nokia-mplslbl:name=current()]/srl_nokia-mplslbl:shared)' {
          error-message "Static label block for binding SIDs should be exclusive (not shared)";
        }
        description
          "Reference to a static label range";
      }
      leaf static-label-block-status {
        config false;
        type enumeration {
          enum available;
          enum unavailable;
        }
        description
          "Status of the label block.

            \t\t\t  The label block may show as unavailable if there is pending cleanup.";
      }
    }
  }

  grouping named-paths {
    container named-paths {
      description
        "Named paths used to specify SR policy segment lists";
      list path {
        key "named-path-name";
        leaf named-path-name {
          type srl_nokia-comm:name;
          description
            "A unique name to identify the named path";
        }
        leaf type {
          description
            "Type named path";
          type enumeration {
            enum ip-hops {
              description
                "Named path consists exclusively of hops identified by IP addresses";
            }
            enum label-hops {
              description
                "Named path consists exclusively of hops identified by MPLS label values";
            }
          }
          default "ip-hops";
        }
        list hop {
          key "index";
          leaf index {
            type uint8;
            description
              "The index number of the hop. Hops are processed in ascending sequence.";
          }
          choice label-or-ip-address {
            case ip-address {
              leaf ip-address {
                must "(../../type = 'ip-hops')" {
                  error-message "named path must be type ip-hops";
                }
                type srl_nokia-comm:ip-address;
                description
                  "An IPv4 or IPv6 address that is a hop to be visited on the way to the destination";
              }
            } //case
            case mpls-label {
              leaf mpls-label {
                must "(../../type = 'label-hops')" {
                  error-message "named path must be type label-hops";
                }
                type srl_nokia-comm:mpls-label-non-reserved;
                description
                  "An MPLS label value representing a segment routing instruction";
              }
            } // case
          } // choice
          leaf hop-type {
            must "(../../type = 'ip-hops')" {
              error-message "named path must be type ip-hops";
            }
            type enumeration {
              enum strict {
                description
                  "A strict hop is always one hop away from the previous hop (or from the head-end in the case of the first hop). TE DB translates each strict hop into an adjacency-SID label. To be resolved to an adjacency SID, a strict hop must be a non-local IP address on a connected subnet (representing the neighbor's interface address on this subnet) or it must be a loopback or system address of the directly-connected neighbor.";
              }
              enum loose {
                description
                  "A loose hop can be any number of hops away from the previous hop (or from the head-end in the case of the first hop). TE DB translates each loose hop into a node-SID label. A loose hop can be any IP address of the remote router associated with the node SID, not just the IP address associated with the node SID itself.

                   Note that the endpoint of the policy is implicitly considered to be a final loose hop. If the final configured hop (previous hop of this implicit loose hop) is unnecessary TEDB indicates this to SR policy manager and the adjacency SID or node SID of the final confgired hop is omitted from the datapath programming.";
              }
            }
          }
        }
      }
    }
  }

  grouping te-policies {
    list policy {
      description
        "List of traffic engineering policies";
      key "policy-name";
      leaf policy-name {
        description
          "The name of the traffic engineering policy";
        type srl_nokia-comm:name;
      }
      leaf policy-type {
        description
          "Specifies the TE policy type

           TE Policy can be of type sr-mpls-colored where label based segment-list or segment-lists constitute a candidate path and color with endpoint is used to configure a path. TE Policy can be of type uncolored in which case a single primary LSP can be backed by one or more secondary LSPs";
        type te-policy-type;
        default "sr-mpls-colored";
      }
      leaf admin-state {
        description
          "Enable/disable the traffic engineering policy";
        type srl_nokia-comm:admin-state;
        default "enable";
      }
      leaf binding-sid {
        description
          "MPLS label that opaquely represents a TE policy to upstream routers";
        type srl_nokia-comm:mpls-label-non-reserved;
        must '../../binding-sid/static-label-block' {
          error-message "A static binding SID label block must be defined";
        }
        must '(current() >= /srl_nokia-system:system/srl_nokia-mplslbl:mpls/srl_nokia-mplslbl:label-ranges/srl_nokia-mplslbl:static[srl_nokia-mplslbl:name=current()/../../binding-sid/static-label-block]/srl_nokia-mplslbl:start-label)'
           + ' and (current() <= /srl_nokia-system:system/srl_nokia-mplslbl:mpls/srl_nokia-mplslbl:label-ranges/srl_nokia-mplslbl:static[srl_nokia-mplslbl:name=current()/../../binding-sid/static-label-block]/srl_nokia-mplslbl:end-label)' {
          error-message "Static bindig SID is outside of the defined range";
        }
      }
      leaf color {
        description
          "Color associated with the sr-mpls-colored TE policy.";
        type uint32 {
          range "0..4294967295";
        }
        must "../policy-type = 'sr-mpls-colored'" {
          error-message "Color is specific to sr-mpls-colored TE policies";
        }
      }
      leaf endpoint {
        mandatory true;
        description
          "Destination of the TE policy";
        type srl_nokia-comm:ip-address-excluding-all-zero;
      }
      leaf distinguisher {
        description
          "Distinguisher value to make different sr-mpls-colored policies unique";
        type uint32;
        must "../policy-type = 'sr-mpls-colored'" {
          error-message "Distinguisher is specific to sr-mpls-colored TE policies";
        }
      }
      leaf head-end {
        description
          "Targeted head end address for an sr-mpls-colored policy";
        type union {
          type srl_nokia-comm:ipv4-address-excluding-all-zero;
          type enumeration {
            enum local {
              value 1;
            }
          }
        }
        must "../policy-type = 'sr-mpls-colored'" {
          error-message "Head-end is specific to sr-mpls-colored TE policies";
        }
      }
      //      leaf tag-set {
      //        description
      //          "Tag set to associate with an sr-mpls-uncolored TE policy";
      //        type leafref {
      //          path "/srl_nokia-routing-pol:routing-policy/srl_nokia-routing-pol:tag-set/srl_nokia-routing-pol:name";
      //        }
      //        must "../policy-type = 'sr-mpls-uncolored'" {
      //          error-message "Tag set is specific to sr-mpls-uncolored TE policies";
      //       }
      //      }
      leaf re-optimization-timer {
        description
          "Re-optimizaion timer for the TE policy";
        type uint32 {
          range "1..360"; //TBD
        }
        units "minutes";
        default "30";
      }
      leaf candidate-path-preference {
        type uint32 {
          range "1..65535";
        }
        description
          "One sr-mpls-colored TE policy is considered better than another sr-mpls-colored for thesame (color, endpoint) if it has a higher preference than the other path.";
        must "../policy-type = 'sr-mpls-colored'" {
          error-message "Preference is specific to sr-mpls-colored TE policies";
        }
      }
      leaf metric {
        description
          "Metric for the TE Policy";
        type uint32 {
          range "1..16777215";
        }
      }
      leaf retry-timer {
        description
          "Time between TE policy re-establishment attempts after failure";
        type uint32 {
          range "1..600";
        }
        units "seconds";
        default "30";
      }
      container ingress-statistics {
        description
          "Enable the ingress-statistics context";
        leaf admin-state {
          type srl_nokia-comm:admin-state;
          default "disable";
          description
            "Administrative state of the traffic statistics";
        }
        //TO-DO: add state leafs
      }
      container egress-statistics {
        description
          "Enable the egress-statistics context";
        leaf admin-state {
          type srl_nokia-comm:admin-state;
          default "disable";
          description
            "Administrative state of the traffic statistics";
        }
        //TO-DO: add state leafs
      }
      leaf maintenance-policy {
        if-feature "srl_nokia-feat:maintenance-policies";
        description
          "The maintenance policy to use with the TE policy";
        type leafref {
          path "/srl_nokia-netinst:network-instance/srl_nokia-maint-pol:maintenance-policies/srl_nokia-maint-pol:policy/srl_nokia-maint-pol:maintenance-policy-name";
        }
      }
      //uses pce-associations;
      uses te-policy-state;
      uses segment-list;
      uses application-bindings;
    }
  }

  grouping application-bindings {
    container application-bindings {
      description
        "Configurable bindings to the TE Policy";
      leaf bgp-unicast {
        description
          "When true, the TE policy is available for next-hop resolution of BGP unlabeled routes";
        type boolean;
        default "true";
      }
      leaf bgp-labeled-unicast {
        description
          "When true, the TE policy is available for next-hop resolution of BGP labeled-unicast routes";
        type boolean;
        default "true";
      }
      leaf ip-vrf {
        description
          "When true, the TE policy is available for next-hop resolution of VPN-IP routes in an ip-vrf network-instance";
        type boolean;
        default "true";
      }
    }
  }

  grouping pce-associations {
    container pce-associations {
      description
        "PCE association policy and diversity ";
      leaf-list diversity {
        max-elements 5;
        description
          "List of diversity names";
        type leafref {
          path "../../../pcep/pcc/pce-associations/diversity/assoc-name";
        }
      }
      leaf-list policy-assocation {
        max-elements 5;
        description
          "List of PCE associations configured under the PCC";
        type leafref {
          path "../../../pcep/pcc/pce-associations/policy/assoc-name";
        }
      }
    }
  }

  grouping segment-list {
    list segment-list {
      key "segment-list-index";
      leaf segment-list-index {
        description
          "Index to enumerate the different segment lists of a TE policy.";
        type uint8 {
          range "1..32";
        }
      }
      leaf admin-state {
        type srl_nokia-comm:admin-state;
        description
          "Administratively enable or disable a segment list";
      }
      leaf named-path {
        type leafref {
          path "../../../named-paths/path/named-path-name";
        }
      }
      leaf segment-list-type {
        description
          "Segment-list type: primary, standby or secondary

           Standby is programmed in datapath, consumes resources and is ready for a failover any time. Secondary is programmed upon failure of the previous active";
        type enumeration {
          enum primary {
            value 0;
          }
          enum secondary {
            value 1;
          }
          enum standby {
            value 2;
          }
        }
        must "not(. = 'secondary' and ../../policy-type = 'sr-mpls-colored' or . = 'standby' and ../../policy-type = 'sr-mpls-colored')" {
          error-message "Only primary is supported for sr-mpls-colored TE policies";
        }
      }
      leaf weight {
        description
          "Weight of this segment list, used for weighted ECMP between segment lists";
        type uint32;
        must "not(../../policy-type = 'sr-mpls-uncolored')" {
          error-message "Weight is only supported for sr-mpls-colored TE policies";
        }
      }
      leaf segment-list-preference {
        //Check with Alp
        description
          "Preference value of this segment-list

           For an sr-mpls-uncolored TE policy one standby segment list is preferred over another if it has a lower preference value. The implicit default value is 100.";
        type uint32 {
          range "1..255";
        }
        must "../segment-list-type = 'standby'" {
          error-message "Only applicable to secondary segment lists";
        }
        must "not(../../policy-type = 'sr-mpls-colored')" {
          error-message "Secondary segment lists are only supported for sr-mpls-uncolored TE policies";
        }
      }
      container priority {
        // Check with Alp
        description
          "Configure setup and hold priorities to be conveyed to the PCE for preemption purposes";
        leaf hold-priority {
          description
            "Hold priority of a TE policy in relation to preemption action";
          type uint8 {
            range "0..7";
          }
          default "0";
        }
        leaf setup-priority {
          description
            "Setup priority of a TE policy in relation to preemption action";
          type uint8 {
            range "0..7";
          }
          default "0";
        }
      }
      leaf pce-control {
        description
          "Set to true for a PCE controlled segment-list";
        type boolean;
        must "not(../named-path) or not(/srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../srl_nokia-netinst:name]/srl_nokia-te-policies:traffic-engineering-policies/srl_nokia-te-policies:named-paths/srl_nokia-te-policies:path[srl_nokia-te-policies:named-path-name=current()/../named-path]/type = 'label-hops')" {
          error-message "No named path or named path type must be ip-hops to use pce-control";
        }
      }
      leaf pce-report {
        description
          "seto to true to enable reporting of the segment-list to the PCE";
        type boolean;
        default "false";
      }
      container dynamic {
        presence "Enable dynamic computation of the segment list";
        must "not(../named-path) or not(/srl_nokia-netinst:network-instance[srl_nokia-netinst:name = current()/../../../../srl_nokia-netinst:name]/srl_nokia-te-policies:traffic-engineering-policies/srl_nokia-te-policies:named-paths/srl_nokia-te-policies:path[srl_nokia-te-policies:named-path-name=current()/../named-path]/type = 'label-hops')" {
          error-message "No named path or named path type must be ip-hops to use dynamic computation";
        }
        description
          "Configuration and state for dynamic segment lists";
        leaf path-algorithm {
          description
            "Path computation method";
          type dynamic-segment-path-computation-type;
          default "local-cspf";
        }
        container te-constraints {
          leaf metric-type {
            description
              "Metric type used for segment-list computation";
            type enumeration {
              enum igp {
                value 1;
              }
              enum te {
                value 2;
              }
            }
            default "igp";
          }
          leaf latency-metric-limit {
            description
              "The maximum latency for the segment-list";
            type uint32;
            default "0"; //Check with Alp
          }
          leaf hop-limit {
            description
              "The maximum number of hops for the segment-list";
            type uint8 {
              range "2..255";
            }
            default "255";
          }
          container segment-depth {
            description
              "Configuration for the maximum number of SIDs/segments";
            leaf segment-limit {
              description
                "The maximum number of segments in the segment-list";
              type uint8 {
                range "1..14";
              }
              default "8"; // To be checked by Srini
            }
            leaf additional-frr-segment-limit {
              description
                "The maximum number of additional segments used for FRR";
              type uint8 {
                range "0..3";
              }
            }
          }
          leaf local-sr-protection {
            description
              "Protection offered for local CSPF computed segment-lists";
            type enumeration {
              enum none {
                value 0;
              }
              enum preferred {
                value 1;
              }
              enum mandated {
                value 2;
              }
            }
            default "preferred";
          }
          leaf label-stack-reduction {
            description
              "Set to true to enable label stack reduction for local CSPF computed segment-lists";
            type boolean;
            default "true";
          }
          leaf-list exclude-hop {
            description
              "Excluded IP addresses from path computation";
            type srl_nokia-comm:ip-address-excluding-all-zero;
            max-elements 10;
          }
          leaf-list exclude-srlg {
            max-elements 16;
            description
              "Excluded SRLGs during path computation";
            type leafref {
              path "../../../../../../srl_nokia-te:traffic-engineering/srl_nokia-te:shared-risk-link-groups/srl_nokia-te:group/srl_nokia-te:name";
            }
          }
          leaf secondary-srlg {
            description
              "Set to to true to consider SRLG for secondary and standby segment list of uncolored type";
            type boolean;
            default "false";
          }
        }
      }
      uses segment-list-oper-state-group;
    }
  }

  grouping policy-database {
    container policy-database {
      config false;
      description
        "Traffic Engineering Policy Database";
      container sr-colored {
        description
          "SR MPLS Policy colored Traffic Engineering Paths";
        list policy {
          key "color endpoint";
          leaf color {
            type uint32;
            description
              "Color associated with the SR MPLS (colored) policy";
          }
          leaf endpoint {
            type srl_nokia-comm:ip-address;
            description
              "Policy endpoint IP address";
          }
          uses candidate-paths;
        }
      }
      container sr-uncolored {
        description
          "Uncolored Traffic Engineering Policy Paths. Also referred to as SR-TE LSPs";
        list policy {
          key "policy-name protocol-origin";
          description
            "Enter the Uncolored Traffic Engineering Policy Path list instance Also refered to as SR-TE LSP list";
          leaf policy-name {
            type srl_nokia-comm:name;
            description
              "Name of Uncolored Traffic Engineering Policy";
          }
          leaf protocol-origin {
            description
              "Uncolored Traffic Engrineering Policy, origination source. The method Policy path is computed. This list includes Path Computation Engine, explicitly configured paths, etc.";
            type protocol-origin-type;
          }
          leaf endpoint {
            type srl_nokia-comm:ip-address;
            description
              "Uncolored Traffic Engineering Policy endpoint IP address";
          }
          leaf head-end {
            type srl_nokia-comm:ip-address;
            description
              "Uncolored Traffic Engineering Policy headend IP address";
          }
          leaf policy-type {
            type te-policy-type;
            description
              "Uncolored Traffic Engineering Policy type";
          }
          leaf tunnel-id {
            type uint32;
            description
              "Uncolored Traffic Engineering Policy unique tunnel identifier";
          }
          leaf metric {
            type uint32;
            description
              "Uncolored Traffic Engineering Policy metric";
          }
          container binding-sid {
            description
              "Identifier that opaquely represents the Uncolored Traffic Engineering Policy (a.k.a. SR-TE LSP) to upstream routers";
            leaf mpls-label {
              description
                "MPLS label that represents the Uncolored Traffic Engineering Policy to upstream routers";
              type srl_nokia-comm:mpls-label-non-reserved;
            }
          }
          leaf created-time {
            description
              "Uncolored Traffic Engineering Policy creation time";
            type srl_nokia-comm:date-and-time;
          }
          leaf segment-list-count {
            description
              "Uncolored Traffic Engineering Policy segment-list count";
            type uint32;
          }
          leaf active-segment-list-index {
            description
              "Uncolored Traffic Engineering Policy active segment-list index";
            type uint32;
          }
          leaf installation-type {
            type enumeration {
              enum tunnel;
              enum swap;
            }
            description
              "TE Policy installation-type definition. If tunnel, TE policy is installed in Tunnel table (LTN) and can be used by local services and IP shortcuts. If installarion-type is swap, it's installed in iLM as a swap entry";
          }
          uses te-policy-state;
          uses dynamic-segment-lists;
        }
      }
    }
  }

  container statistics {
    config false;
    leaf ingress-packets {
      type srl_nokia-comm:zero-based-counter64;
      config false;
      description
        "Number of packets received by the TE policy";
    }
    leaf ingress-octets {
      type srl_nokia-comm:zero-based-counter64;
      config false;
      units "byte";
      description
        "Number of octets received by the TE policy";
    }
    leaf egress-packets {
      type srl_nokia-comm:zero-based-counter64;
      config false;
      description
        "Number of packets transmitted by the TE policy";
    }
    leaf egress-octets {
      type srl_nokia-comm:zero-based-counter64;
      config false;
      units "byte";
      description
        "Number of octets transmitted by the TE policy";
    }
  }

  grouping candidate-paths {
    description
      "SR policy candidate path grouping";
    list candidate-path {
      description
        "SR policy candidate paths. This list includes local static policies, but only those that have both a color and endpoint.";
      key "candidate-path-index";
      leaf candidate-path-index {
        type uint8;
        description
          "Index to enumerate the different candidate paths for a (color, endpoint).";
      }
      leaf protocol-origin {
        type protocol-origin-type;
        description
          "Instantiation mechanism used to create the candidate path";
      }
      leaf originator {
        type string;
        description
          "Identifier (concatenation of ASN and node-address) of the node that signalled/instantiated the candidate path on headend";
      }
      leaf discriminator {
        type uint32;
        description
          "Candidate path distinguisher";
      }
      leaf preference {
        type uint32 {
          range "1..65535";
        }
        description
          "Candidate path preference";
      }
      leaf binding-sid {
        type srl_nokia-comm:mpls-label-non-reserved;
        description
          "The binding SID of the candidate path.";
      }
      uses policy-state;
      uses dynamic-segment-lists;
    }
  }

  grouping te-policy-state {
    leaf oper-state {
      config false;
      type te-policy-oper-state;
      description
        "Traffic Engineering policy operational state.";
    }
    leaf oper-down-reason {
      config false;
      type te-policy-oper-down-reason-type;
      description
        "The reason why the Traffic Engineering policy is operationally down.

         One of the following values:
         -  te-policy-admin-disabled: the TE policy is administratively disabled
         -  te-policy-no-valid-segment-list: the TE policy has no valid segment lists";
    }
    leaf oper-state-change-count {
      config false;
      type uint32;
      description
        "Traffic Engineering Policy operational state change count
         Operational status trnasition from up to down, down to up, etc all accounted under this counter";
    }
    leaf last-oper-state-change {
      config false;
      type srl_nokia-comm:date-and-time-delta;
      description
        "Time elapsed since the last operational state change for the Traffic Engineering Policy";
    }
  }

  grouping dynamic-state {
    description
      "Dynamic Segment List state";
    container dynamic {
      config false;
      description
        "Dynamic Segment List";
      leaf path-algorithm {
        description
          "Algorithm used for computation of the Segment List";
        type dynamic-segment-path-computation-type;
      }
      container te-constraints {
        description
          "Traffic Engineering constraints for dynamic segment-lists";
        leaf hop-limit {
          description
            "Hop limit contraint used for computation of the Segment List";
          type uint8;
        }
        leaf label-stack-reduction {
          description
            "If label stack reduction is enabled for the given Segment List";
          type boolean;
        }
        leaf exclude-srlg {
          description
            "SRLG links excluded during path computation for the given Segment List";
          type string;
        }
        leaf local-sr-protection {
          description
            "If local SR protection is requested for the given Segment List";
          type boolean;
        }
        leaf exclude-hop {
          description
            "Excluded IP addresses from path computation for the given Segment List";
          type srl_nokia-comm:ip-address-excluding-all-zero;
        }
        leaf segment-depth {
          description
            "Number of segments pushed while instantiating the Segment List";
          type uint8;
        }
        leaf metric-type {
          description
            "Metric type used for segment-list computation";
          type enumeration {
            enum igp {
              value 1;
            }
            enum te {
              value 2;
            }
          }
        }
        leaf secondary-srlg {
          description
            "If SRLG constraints are taken into account while computing Secondary Segment List";
          type boolean;
        }
      }
    }
    uses computed-hops;
  }

  grouping last-pce-update {
    container last-pce-update {
      leaf time {
        config false;
        description
          "Indicates the system time when the last update occured.";
        type srl_nokia-comm:date-and-time;
      }
      leaf update-id {
        config false;
        description
          "Indicates the last update ID which was processed.";
        type uint32;
      }
      leaf state {
        config false;
        description
          "Indicates whether the last update was successful or failed.";
        type enumeration {
          enum success {
            value 0;
          }
          enum failure {
            value 1;
          }
        }
      }
      leaf failure-reason {
        config false;
        description
          "Indicates the reason code for last MBB failure.";
        type segment-list-invalid-reason-type;
      }
    }
  }

  grouping bfd-state {
    container bfd {
      leaf bfd-state {
        config false;
        description
          "The current state of the BFD session on the LSP path.";
        type enumeration {
          enum not-applicable {
            value 0;
          }
          enum down {
            value 1;
          }
          enum up {
            value 2;
          }
        }
      }
      leaf bfd-wait-for-up-expiry {
        config false;
        description
          "The time in seconds left to wait for the bfd session to be up.";
        type srl_nokia-comm:date-and-time-delta;
      }
      leaf session-request-id {
        config false;
        description
          "Id used for BFD session request.";
        type uint32;
      }
    }
  }

  grouping computed-hops {
    container computed-hops {
      list hop {
        key "hop-index";
        leaf hop-index {
          type uint8;
          description
            "Index to enumerate the different segments in a segment-list";
        }
        leaf hop-type {
          config false;
          description
            "Hop type.";
          type enumeration {
            enum ipv4 {
              value 1;
            }
            enum ipv6 {
              value 2;
            }
            //enum as-number { value 3; }//not-supported
            enum unnum {
              value 4;
            }
          }
        }
        leaf ip-address {
          config false;
          description
            "IP Address for this hop.";
          type srl_nokia-comm:ip-address;
        }
        leaf is-loose {
          config false;
          description
            "Indicates if this tunnel hop is loose.";
          type boolean;
        }
        leaf unnumbered-if-id {
          config false;
          description
            "The value of unnumbered interface identifier of this hop.";
          type uint32;
        }
        leaf router-id {
          config false;
          description
            "The value of router ID.";
          type uint64;
        }
        container sid-value {
          leaf mpls-label {
            description
              "Label recorded for this hop.";
            type uint32;
          }
        }
        leaf sid-type {
          config false;
          description
            "Type of Segment Identifier (SID).";
          type enumeration {
            enum not-applicable {
              value 1;
            }
            enum node-sid {
              value 2;
            }
            enum adjacency-sid {
              value 3;
            }
          }
        }
      }
    }
  }

  grouping policy-state {
    leaf path-type {
      config false;
      type candidate-path-type;
      description
        "The candidate path type.

         One of the following values:
         -  best: the policy is the best valid path but it does not have a protection policy with SBFD enabled
         -  primary: the policy is the best valid path and it has a protection policy with SBFD enabled
         -  secondary: the policy is the second best valid path and it has a protection policy with SBFD enabled
         -  tertiary: the policy is the third best valid path and it has a protection policy with SBFD enabled
         -  other: the policy is any other path";
    }
    leaf valid {
      config false;
      type boolean;
      description
        "True when the candidate path is valid.";
    }
    leaf invalid-reason {
      config false;
      type policy-invalid-reason-type;
      description
        "The reason why the candidate path is invalid.

         One of the following values:
         -  admin-disabled: the candidate path is administratively disabled
         -  no-valid-segment-list: the candidate path has no valid segment lists
         -  binding-sid-failed: no free labels in the label-range or ILM programming failed
         -  tunnel-programming-failed: programming failed due to exhaustion of tunnel, NHLFE or other datapath resources";
    }
    leaf protection-available {
      config false;
      type boolean;
      description
        "True when this (primary) candidate path is protected by another pre-programmed candidate path.

         For a primary path to be protected all of the following conditions must be met:
         -  the primary path is bound to a protection-policy with seamless-bfd set to true
         -  there is a secondary path with a protection-policy having seamless-bfd set to true and the associated SBFD session is currently up OR there is a tertiary path with a protection-policy having seamless-bfd set to true and the associated SBFD session is currently up";
    }
    leaf last-oper-state-change {
      config false;
      type srl_nokia-comm:date-and-time-delta;
      description
        "Time elapsed since the last operational state change for the Traffic Engineering Policy";
    }
  }

  grouping dynamic-segment-lists {
    list segment-list {
      key "segment-list-index";
      leaf segment-list-index {
        type uint8 {
          range "1..32";
        }
        description
          "Index to enumerate the different segment lists.";
      }
      uses segments-state;
      uses segment-list-oper-state-group;
      uses segment-list-state;
    }
  }

  grouping segments-state {
    list segment {
      key "segment-index";
      leaf segment-index {
        type uint8;
        description
          "Index to enumerate the different segments in a segment-list";
      }
      container segment-type-a {
        description
          "Segment identified by MPLS label";
        leaf sid-value {
          type srl_nokia-comm:mpls-label-non-reserved;
          description
            "MPLS label value";
        }
      }
    }
  }

  grouping segment-list-oper-state-group {
    leaf oper-state {
      config false;
      type segment-list-oper-state;
      description
        "Segment list operational state";
    }
    leaf invalid-reason {
      config false;
      type segment-list-invalid-reason-type;
      description
        "The reason why the segment list is invalid.

         One of the following values:
         -  unresolved-first-segment: the first SID (MPLS label value) cannot be resolved into one or more outgoing interface(s) and next-hop(s)
         -  unresolved-named-path: the most recent query to TEDB about the named path (triggered by periodic re-optimization or initially) indicated that the named path is not viable";
    }
    leaf last-oper-state-change {
      config false;
      type srl_nokia-comm:date-and-time-delta;
      description
        "Time elapsed since the last opertional state change for the segment-list";
    }
    leaf oper-state-change-count {
      config false;
      type uint32;
      description
        "Traffic Engineering Policy segment-list operational state change count
         Operational status trnasition from up to down, down to up, etc all accounted under this counter";
    }
  }

  grouping segment-list-state {
    leaf segment-list-type {
      config false;
      type enumeration {
        enum primary {
          value 0;
        }
        enum secondary {
          value 1;
        }
        enum standby {
          value 2;
        }
      }
      description
        "Segment-list type: primary, standby or secondary
         Standby is programmed in datapath, consumes resources and is ready for a failover any time. Secondary is programmed upon failure of the previous active";
    }
    leaf pce-report {
      description
        "PCE Reporting for Traffic Engineering Policy Segment-list";
      type boolean;
    }
    leaf pce-control {
      description
        "PCE Control status for Traffic Engineering Policy Segment-list";
      type boolean;
    }
    leaf segment-list-preference {
      description
        "Segment List preference for a given list under Traffic Engineering Policy";
      type uint8;
    }
    leaf named-path {
      description
        "Named-path used for instantiating Segment List under Traffic Engineering Policy";
      type srl_nokia-comm:name;
    }
    leaf metric {
      description
        "Metric of a given Segment List";
      type uint32;
    }
    leaf lsp-id {
      config false;
      type uint32;
      description
        "Unique internal identifier of segment-list";
    }
    // Alp: to be postponed till oper-state is finalized
    //    leaf transition-count {
    //      config false;
    //      type uint32;
    //      description
    //        "Number of up-to-down and down-to-up transitions for the segment-list";
    //    }
    leaf retry-attempts {
      config false;
      type uint32;
      description
        "Number of unsuccessful attempts made to signal the segment-list";
    }
    leaf last-retry-attempt {
      config false;
      type srl_nokia-comm:date-and-time-delta;
      description
        "Time elapsed since the last retry attempt to re-established the segment-list";
    }
    leaf last-reoptimization-attempt {
      config false;
      type srl_nokia-comm:date-and-time-delta;
      description
        "Time elapsed since last path re-optimization attempt on the segment-list";
    }
    leaf next-retry-attempt {
      config false;
      type srl_nokia-comm:date-and-time-delta;
      description
        "Time remaining for next retry attempt to re-established the segment-list";
    }
    leaf next-reoptimization-attempt {
      config false;
      type srl_nokia-comm:date-and-time-delta;
      description
        "Time remaining for next path re-optimization attempt on the segment-list";
    }
    leaf path-computation-requests {
      config false;
      type uint32;
      description
        "Number of path computation requests made for the segment-list";
    }
    uses bfd-state;
    uses dynamic-state;
    uses mbb-state;
  }

  grouping mbb-state {
    container mbb {
      config false;
      description
        "The make-before-break operational information.";
      container last-mbb {
        description
          "The last make-before-break operational information.";
        leaf type {
          description
            "Indicates the type of the make-before-break (MBB) that is in progress.";
          type enumeration {
            enum none {
              value 0;
            }
            enum timer-based-reoptimization {
              value 1;
            }
            enum manual-resignal {
              value 2;
            }
            enum pce-update {
              value 3;
            }
          }
        }
        leaf state {
          description
            "Indicates whether the last make-before-break was successful or failed.";
          type enumeration {
            enum success {
              value 0;
            }
            enum failure {
              value 1;
            }
          }
        }
        leaf end-time {
          description
            "Specifies the system time when the last MBB ended.";
          type srl_nokia-comm:date-and-time;
        }
        leaf failed-reason {
          description
            "Indicates the reason code for last MBB failure.";
          type segment-list-invalid-reason-type;
        }
      }
      container in-progress-mbb {
        description
          "The in progress make-before-break operational information.";
        leaf type {
          description
            "Indicates the type of the make-before-break (MBB) that is in progress.";
          type enumeration {
            enum none {
              value 0;
            }
            enum timer-based-reoptimization {
              value 1;
            }
            enum manual-resignal {
              value 2;
            }
            enum pce-update {
              value 3;
            }
          }
        }
        leaf start-time {
          description
            "Indicates the system time when the in-progress MBB started.";
          type srl_nokia-comm:date-and-time;
        }
      }
    }
  }

  augment "/srl_nokia-netinst:network-instance" {
    uses te-policies-top;
  }
}
